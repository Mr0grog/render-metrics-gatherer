const baseCronRun = {
  serviceId: "",
  runId: "",
  sinceLastRunFinished: -1,
  duration: -1,
  queueDuration: -1,
  startDelay: -1,
  status: -1,
  reason: null,
  /** @type {Date} */
  queueTime: null,
  /** @type {Date} */
  startTime: null,
  /** @type {Date} */
  endTime: null,
}

/**
 * Remove terminal control sequences (e.g. colors, character set selection) from
 * a text string. This is not remotely comprehensive, but covers most of what
 * we get from logs generated by Render itself.
 * @param {string} text
 * @returns {string}
 */
 function removeTtyControlSequences(text) {
  return text.replace(/\u{001b}(\[[\d;]*[a-zA-Z]|\([a-zA-Z])/gu, "");
}

/**
 * Create an array of "run" objects representing information about the timing
 * and success of each cron service's run. This combines information from
 * start and end events plus the actual run start time from logs (events only
 * tell us when a run was *queued*) to create each run object.
 * @param {any[]} events
 * @param {any[]} logs
 * @returns {baseCronRun[]}
 */
async function createCronRuns(serviceId, events, logs) {
  const runStartTimes = [];
  for (const logLine of logs) {
    const printedText = removeTtyControlSequences(logLine.text);
    if (printedText.startsWith("==> Starting service")) {
      runStartTimes.push(logLine.timestamp);
    }
  }

  const runs = new Map();
  for (const event of events) {
    const runId = event.cronJobRunId;
    if (runId) {
      let run = runs.get(runId);
      if (!run) {
        run = { ...baseCronRun, serviceId, runId };
        runs.set(runId, run);
      }

      const timestamp = new Date(event.timestamp);
      if (event.__typename === 'CronJobRunStarted') {
        run.queueTime = new Date(timestamp);
      } else if (event.__typename === 'CronJobRunEnded') {
        run.endTime = new Date(timestamp);
        run.status = event.status;
        run.reason = event.reason;
      } else {
        console.warn("Event has runId but is not a start or end:", event);
      }
      if (run.queueTime && run.endTime) {
        run.queueDuration = run.endTime - run.queueTime;
      }
    }
  }

  let sortedRuns = [...runs.values()].sort((a, b) => b.startTime - a.startTime);
  let nextNewerRun = null;
  // console.warn(sortedRuns.length, "queued runs")
  // console.warn(runStartTimes.length, "started runs");

  let latestStart = runStartTimes.pop();
  let latestTimestamp = latestStart ? new Date(latestStart / 1_000_000) : null;
  for (const run of sortedRuns) {
    if (nextNewerRun) {
      nextNewerRun.sinceLastRunFinished = nextNewerRun.queueTime - run.endTime;
    }
    nextNewerRun = run;

    while (latestTimestamp && latestTimestamp > run.queueTime) {
      run.startTime = latestTimestamp;
      run.duration = run.endTime - run.startTime;
      run.startDelay = run.startTime - run.queueTime;
      latestStart = runStartTimes.pop();
      latestTimestamp = latestStart ? new Date(latestStart / 1_000_000) : null;
    }
  }

  return sortedRuns;
}

module.exports = {
  createCronRuns,
  removeTtyControlSequences,
};
